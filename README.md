---

# Theil-Sen Estimator C 語言實作 (AVX 優化)

使用 C 語言實現的 Theil-Sen。Theil-Sen 估計法是一種穩健的線性迴歸方法，對於數據中的離群值 (outliers) 較不敏感。本專案不僅實現了標準的 Theil-Sen 演算法，還提供了一個滑動視窗版本，可用於計算時間序列數據的基線 (baseline)。

為了追求高效能，此實作大量運用了 **AVX (Advanced Vector Extensions)** 指令集進行 SIMD (單指令多資料流) 平行運算，並透過記憶體對齊等技術進一步優化。

## ✨ 主要功能

- **標準 Theil-Sen 迴歸分析**：`theil_sen()` 函式可計算一組 (x, y) 數據點的迴歸線，找出截距 (intercept) 和斜率 (slope)。
- **滑動視窗 Theil-Sen 基線計算**：`theil_sen_window()` 函式可對單一數值序列 (如時間序列) 進行滑動視窗分析，計算出每個視窗內的趨勢線，作為原始數據的基線。
- **高效能 AVX 優化**：核心計算部分 (如點對斜率計算、截距計算) 使用 AVX2 intrinsics 函式庫，可同時處理 8 個浮點數，大幅提升運算速度。
- **記憶體對齊**：使用 `posix_memalign` 確保記憶體位址為 32-byte 對齊，滿足 AVX 高效讀取的需求。
- **C++ 相容**：頭文件使用 `extern "C"` 包裝，確保 C++ 專案也能順利引用。

## 📁 檔案結構

- **`main.c`**: 範例主程式。展示了如何使用 `theil_sen` 和 `theil_sen_window` 兩個主要函式。
- **`theil_sen.h`**: 函式庫的頭文件。定義了外部可用的 API 接口。
- **`theil_sen.c`**: Theil-Sen 演算法的具體實現。包含了核心邏輯、AVX 優化和輔助函式。

## ⚙️ 核心演算法說明

Theil-Sen 估計法透過以下兩個步驟來確定一條迴歸線 `y = α + βx`：

1.  **計算斜率 (β)**：
    -   找出數據中所有點對 (pairs of points)。
    -   計算每一對點 `(x_i, y_i)` 和 `(x_j, y_j)` 之間的斜率：`(y_j - y_i) / (x_j - x_i)`。
    -   迴歸線的最終斜率 `β` 是所有這些點對斜率的 **中位數 (median)**。

2.  **計算截距 (α)**：
    -   利用算出的斜率 `β`，為每一個數據點 `(x_i, y_i)` 計算一個對應的截距：`y_i - β * x_i`。
    -   迴歸線的最終截距 `α` 是所有這些截距的 **中位數**。

由於此演算法使用中位數而非平均數，因此能有效抵抗少數極端值 (離群值) 的影響，使其結果更加穩健。

## 🚀 效能優化技術

本專案的核心目標之一是高效能，主要透過以下方式實現：

-   **AVX (Advanced Vector Extensions)**：在 `pointwise_slope` 和 `theil_sen` 函式中，可以看到大量 `__m256` 型別和 `_mm256_*` 開頭的函式。這些是 AVX intrinsics，它們將多筆浮點數（在此為 8 個）打包成一個 256-bit 的向量，並用單一 CPU 指令完成加、減、乘、除等運算，實現了 SIMD 平行化。

-   **記憶體對齊 (Memory Alignment)**：為了讓 AVX 指令達到最佳效能，讀取的記憶體位址必須是 32-byte 的倍數。程式中的 `align_malloc` 函式使用 `posix_memalign` 來分配對齊的記憶體空間，避免了非對齊讀取造成的效能損失。

## 🛠️ 如何編譯與執行

本專案程式碼使用了 AVX 指令集，因此在編譯時需要開啟相關的編譯器旗標。建議使用 `gcc` 或 `clang`。

1.  **編譯指令**：
    打開您的終端機，並使用以下指令進行編譯。`-mavx` 旗標是必須的，它會告訴編譯器啟用 AVX 指令集。`-O2` 或 `-O3` 為推薦的優化等級。

    ```bash
    gcc main.c theil_sen.c -o theil_sen_demo -mavx -O2 -lm
    ```

2.  **執行**：
    編譯成功後，會生成名為 `theil_sen_demo` 的執行檔。

    ```bash
    ./theil_sen_demo
    ```

3.  **預期輸出**：
    執行後，您將會看到 `main.c` 中兩個案例的計算結果。

    ```
    (Model: y = 1.057143 + 0.142857 * x)
    Original (y) -> Baseline (res)
    y[00]:  1.10 -> res[00]:  1.20
    y[01]:  1.30 -> res[01]:  1.50
    y[02]:  1.90 -> res[02]:  1.80
    y[03]:  2.10 -> res[03]:  2.10
    y[04]:  3.00 -> res[04]:  3.02
    y[05]:  3.20 -> res[05]:  3.45
    y[06]:  3.90 -> res[06]:  3.88
    y[07]:  4.10 -> res[07]:  4.30
    y[08]:  5.00 -> res[08]:  4.85
    y[09]:  5.30 -> res[09]:  5.30
    ```

## 📚 API 文件

### `void theil_sen(float* x, float* y, float* res, size_t n)`

計算一組數據點的 Theil-Sen 迴歸線。

-   **參數**:
    -   `float* x`: 指向 x 座標陣列的指標。
    -   `float* y`: 指向 y 座標陣列的指標。
    -   `float* res`: 指向大小為 2 的浮點數陣列，用於儲存結果。`res[0]` 將存放截距 (α)，`res[1]` 將存放斜率 (β)。
    -   `size_t n`: 數據點的數量。

### `void theil_sen_window(float* y, float* res, size_t n, size_t win_size)`

對一維數據序列進行滑動視窗 Theil-Sen 分析，計算基線。

-   **參數**:
    -   `float* y`: 指向輸入的數據序列陣列。
    -   `float* res`: 指向與 `y` 等長的陣列，用於儲存計算出的基線結果。
    -   `size_t n`: `y` 陣列的總長度。
    -   `size_t win_size`: 滑動視窗的大小。

## 💡 範例解析

`main.c` 中的範例展示了此函式庫的兩種典型用法：

1.  **案例一：標準迴歸分析**
    -   提供一組 `x` 和 `y` 數據。
    -   呼叫 `theil_sen()` 函式。
    -   函式會計算出最佳擬合的迴歸線 `y = α + βx`，並將 `α` 和 `β` 存入 `results` 陣列。
    -   最後印出模型公式。

2.  **案例二：滑動視窗基線**
    -   只提供一組 `y2` 數據（可視為時間序列）。
    -   呼叫 `theil_sen_window()`，並設定視窗大小為 4。
    -   函式會將 `y2` 數據每 4 個一組進行 Theil-Sen 分析（此時 x 座標被隱含地當作 `0, 1, 2, 3`）。
    -   計算每個視窗內的趨勢線數值，並填入 `results2` 陣列中，形成一條平滑的基線。
    -   最後將原始值與計算出的基線值並列印出，方便比較。
