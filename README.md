-----

# PELT 演算法 C 語言實作

使用 C 語言實現的 **PELT (Pruned Exact Linear Time)** 演算法。PELT 是一種高效能的 changepoint detection (變點偵測) 演算法，用於在時間序列數據中找出統計特性（如平均值或變異數）發生顯著變化的時間點。

本專案實現了 PELT 演算法，以高斯分佈的負對數概似 (negative log-likelihood) 作為成本函數 (cost function)，能夠精確且快速地找出多個變點。

為了追求高效能，此實作利用 **累計和 (cumulative sums)** 技術，將計算任意區段成本的時間複雜度降至 O(1)。結合 PELT 演算法本身的 **剪枝 (pruning)** 機制，使得整體演算法在許多情況下能達到近乎線性的 O(n) 執行效率，遠優於 O(n^2) 的傳統動態規劃方法。

## ✨ 主要功能

  - **精確變點偵測**：`pelt()` 函式可對一維浮點數序列進行分析，找出統計特性發生變化的精確索引位置。
  - **高效 PELT 演算法**：實現 Pruned Exact Linear Time (PELT) 演算法，透過動態規劃與剪枝機制，大幅提升變點偵測的速度。
  - **O(1) 成本計算**：使用「累計和」(cumulative sum) 與「平方累計和」(cumulative sum of squares) 技巧，使得計算任一子區段 (segment) 的成本函數變為 O(1) 時間。
  - **高斯成本函數**：內建的成本函數是基於高斯分佈的負對數概似 (negative log-likelihood)，使其特別適用於偵測數據平均值 (mean) 的變化。
  - **可自訂懲罰項**：函式介面允許傳入 `penalty` 值，讓使用者能根據 AIC、BIC (如範例所示) 或其他準則來控制模型的複雜度，避免過度擬合 (overfitting)。

## 📁 檔案結構

  - **`main.c`**: 範例主程式。展示了如何生成測試數據、設定懲罰項，並呼叫 `pelt()` 函式來找出變點。
  - **`pelt.h`**: 函式庫的頭文件。定義了外部可用的 `pelt` API 接口。
  - **`pelt.c`**: PELT 演算法的具體實現。包含了核心邏輯、O(1) 成本函數、剪枝步驟和變點回溯。

## ⚙️ 核心演算法說明

PELT 演算法透過動態規劃 (Dynamic Programming) 來找出最佳的變點組合，其目標是最小化以下總成本：

> 總成本 = Σ (所有區段的成本) + (變點數量 \* 懲罰項)

1.  **成本函數 (Cost Function)**：

      - 本實作使用高斯分佈的負對數概似 (negative log-likelihood) 作為成本函數。
      - 此函數假設一個區段內的數據服從同一個高斯分佈，並計算其概似值。
      - 為了能在 O(1) 時間內計算任一區段 `(start, end)` 的成本，程式預先計算了 `cum_sum` (累計和) 和 `cum_sum2` (平方累計和)。

2.  **動態規劃 (Dynamic Programming)**：

      - 令 `F(t)` 為數據點 `data[0...t]` 的最小總成本。
      - 一個 O(n^2) 的動態規劃解法遞迴式為：
        `F(t) = min_{0 <= tau < t} [ F(tau) + cost(tau, t) + penalty ]`
      - `cp[t]` 儲存使得 `F(t)` 最小的 `tau` 值，即 `t` 點之前的最佳變點位置。

3.  **剪枝 (Pruning)**：

      - PELT 演算法的核心優化。它維護一個候選變點集合 `R`。
      - 在計算 `F(t)` 時，我們不需檢查所有 `0 <= tau < t`，只需檢查 `R` 集合中的 `tau`。
      - 在計算完 `F(t)` 後，`R` 集合會被更新（剪枝）：
          - 只保留那些在未來 *有可能* 成為最佳變點的 `tau`。
          - 剪枝的準則是：如果 `tau_i` 滿足 `F(tau_i) + cost(tau_i, t) <= F(t)`，它就會被保留。
          - 最後將 `t` 本身加入 `R` 集合，作為下一次迭代的候選點。
      - 這個剪枝步驟能有效將候選集 `R` 的大小維持在一個較小範圍，使演算法的平均時間複雜度降至 O(n)。

4.  **回溯 (Backtracing)**：

      - 當 `F(n_series)` 計算完畢後，從 `cp[n_series]` 開始反向追蹤，即可依序找出所有的最佳變點位置。

## 🚀 效能優化技術

本專案的核心效能優化來自於演算法層面：

  - **O(1) 成本計算**：在 `pelt` 函式的一開始，程式會花費 O(n) 時間預先計算 `cum_sum` 和 `cum_sum2` 兩個累計和陣列。這使得 `cost` 函式在計算任意區段 `(start, end)` 的成本時，只需進行幾次陣列索引和簡單的算術運算，時間複雜度為 O(1)。

  - **PELT 剪枝**：演算法的關鍵。在 `pelt` 函式的主迴圈中，`R` 陣列儲存了候選變點。`new_R_len` 的更新過程即為剪枝步驟。它排除了那些「成本過高，在未來不可能成為最佳解」的舊候選點，使得內層迴圈的迭代次數遠小於 `t`，從而將整體時間複雜度從 O(n^2) 降至近乎 O(n)。

## 🛠️ 如何編譯與執行

本專案程式碼使用了標準 C 函式庫以及 `math.h`。

1.  **編譯指令**：
    打開您的終端機，並使用以下指令進行編譯。`-lm` 旗標是連結數學函式庫所必需的（因為使用了 `logf` 和 `M_PI` 等）。`-O2` 或 `-O3` 為推薦的優化等級。

    ```bash
    gcc main.c pelt.c -o pelt_demo -O2 -lm
    ```

2.  **執行**：
    編譯成功後，會生成名為 `pelt_demo` 的執行檔。

    ```bash
    ./pelt_demo
    ```

3.  **預期輸出**：
    執行後，您將會看到 `main.c` 中 `generate_test_data` 所產生的數據被 `pelt` 演算法分析後的結果。測試數據在索引 50 和 100 處有明顯的均值變化。

    ```
    Found 3 changepoints:
      -> Index: 50
      -> Index: 100
      -> Index: 150
    ```

    *(註：索引 150 為序列的終點，此為演算法的標準回傳，代表最後一個區段的結束點。)*

## 📚 API 文件

### `void pelt(const float* data, size_t n_series, float penalty, int* changepoints, int* n_changepoints)`

對一維數據序列執行 PELT 變點偵測。

  - **參數**:
      - `const float* data`: 指向輸入的 1D 數據序列陣列。
      - `size_t n_series`: `data` 陣列的總長度。
      - `float penalty`: 懲罰項常數。此值會乘上變點的數量，作為總成本的一部分。
      - `int* changepoints`: 指向一個已分配好記憶體（建議大小至少為 `n_series`）的整數陣列，用於儲存偵測到的變點索引。
      - `int* n_changepoints`: 指向一個整數，函式會將找到的變點總數寫入此位置。

## 💡 範例解析

`main.c` 中的範例展示了此函式庫的典型用法：

1.  **產生測試數據**：

      - `generate_test_data` 函式創建了一個長度為 150 的序列。
      - 索引 0-49 的均值為 0.0。
      - 索引 50-99 的均值變為 5.0（第一個變點）。
      - 索引 100-149 的均值回復為 0.0（第二個變點）。
      - 所有數據點都加上了微小的隨機雜訊。

2.  **設定懲罰項**：

      - 範例使用 `penalty = 2.0f * logf((float)n_series)`。當成本函數為負對數概似時，`2 * log(n)` 的懲罰項對應了 **BIC (Bayesian Information Criterion)** 準則，這是一種常見的、傾向於選擇較簡潔模型的懲罰方式。

3.  **執行與結果**：

      - 呼叫 `pelt()` 函式進行分析。
      - 函式成功在索引 50 和 100 偵測到均值的變化。
      - 最後印出的 `150` 是序列的結尾，代表最後一個區段的結束。
